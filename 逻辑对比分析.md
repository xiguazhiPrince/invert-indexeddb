# 代码逻辑对比分析报告

## 概述
本次更改将直接使用 IndexedDB API 的代码重构为使用 Store 类封装。以下是详细的逻辑对比。

---

## 1. src/index.ts 文件

### 1.1 getDocument 方法
**原始逻辑：**
```typescript
return new Promise((resolve, reject) => {
  const store = this.db.getStore(STORE_NAMES.DOCUMENTS);
  const request = store.get(docId);
  request.onsuccess = () => {
    resolve(request.result || null);
  };
  request.onerror = () => reject(request.error);
});
```

**新逻辑：**
```typescript
return await this.documentsStore.get<T>(docId);
```

**DocumentsStore.get 实现：**
```typescript
async get<T = any>(docId: string): Promise<T | null> {
  return new Promise((resolve, reject) => {
    const store = this.db.getStore(STORE_NAMES.DOCUMENTS);
    const request = store.get(docId);
    request.onsuccess = () => {
      resolve(request.result || null);
    };
    request.onerror = () => {
      const error = request.error || new Error('Unknown error');
      reject(new Error(`Failed to get document: ${error.message}`));
    };
  });
}
```

**✅ 结论：逻辑一致**（仅错误处理稍有增强）

---

### 1.2 saveDocument 方法
**原始逻辑：**
```typescript
return new Promise((resolve, reject) => {
  const store = this.db.getStore(STORE_NAMES.DOCUMENTS, 'readwrite');
  const request = store.put(doc);
  request.onsuccess = () => resolve();
  request.onerror = () => reject(request.error);
});
```

**新逻辑：**
```typescript
await this.documentsStore.put(doc);
```

**DocumentsStore.put 实现：**
```typescript
async put<T = any>(doc: T): Promise<void> {
  return new Promise((resolve, reject) => {
    const store = this.db.getStore(STORE_NAMES.DOCUMENTS, 'readwrite');
    const request = store.put(doc);
    request.onsuccess = () => resolve();
    request.onerror = () => {
      const error = request.error || new Error('Unknown error');
      reject(new Error(`Failed to save document: ${error.message}`));
    };
  });
}
```

**✅ 结论：逻辑一致**（仅错误处理稍有增强）

---

### 1.3 deleteDocumentFromStore 方法
**原始逻辑：**
```typescript
return new Promise((resolve, reject) => {
  const store = this.db.getStore(STORE_NAMES.DOCUMENTS, 'readwrite');
  const request = store.delete(docId);
  request.onsuccess = () => resolve();
  request.onerror = () => reject(request.error);
});
```

**新逻辑：**
```typescript
await this.documentsStore.delete(docId);
```

**DocumentsStore.delete 实现：**与原始逻辑相同

**✅ 结论：逻辑一致**

---

### 1.4 saveDocFields 方法
**原始逻辑：**
```typescript
return new Promise((resolve, reject) => {
  const store = this.db.getStore(STORE_NAMES.DOC_FIELDS, 'readwrite');
  const request = store.put({
    docId,
    fields: fieldValues,
  });
  request.onsuccess = () => resolve();
  request.onerror = () => reject(request.error);
});
```

**新逻辑：**
```typescript
await this.docFieldsStore.put(docId, fieldValues);
```

**DocFieldsStore.put 实现：**
```typescript
async put(docId: string, fields: Record<string, any>): Promise<void> {
  return new Promise((resolve, reject) => {
    const store = this.db.getStore(STORE_NAMES.DOC_FIELDS, 'readwrite');
    const request = store.put({
      docId,
      fields,
    });
    request.onsuccess = () => resolve();
    request.onerror = () => {
      const error = request.error || new Error('Unknown error');
      reject(new Error(`Failed to save doc fields: ${error.message}`));
    };
  });
}
```

**✅ 结论：逻辑一致**（仅错误处理稍有增强）

---

### 1.5 getAllDocuments 方法
**原始逻辑：**
```typescript
return new Promise((resolve, reject) => {
  const store = this.db.getStore(STORE_NAMES.DOCUMENTS);
  const request = store.getAll();
  request.onsuccess = () => {
    const docs = new Map<string, any>();
    if (request.result) {
      for (const doc of request.result) {
        if (doc.docId) {
          docs.set(doc.docId, doc);
        }
      }
    }
    resolve(docs);
  };
  request.onerror = () => reject(request.error);
});
```

**新逻辑：**
```typescript
return await this.documentsStore.getAll();
```

**DocumentsStore.getAll 实现：**与原始逻辑完全相同

**✅ 结论：逻辑一致**

---

### 1.6 clearIndexes 方法
**原始逻辑：**
```typescript
const promises = [
  this.clearStore(STORE_NAMES.INVERTED_INDEX),
  this.clearStore(STORE_NAMES.DOC_TERMS),
];
await Promise.all(promises);
```

**新逻辑：**
```typescript
await Promise.all([
  this.invertedIndexStore.clear(),
  this.docTermsStore.clear()
]);
```

**Store.clear 实现：**与原始 clearStore 逻辑相同

**✅ 结论：逻辑一致**

---

## 2. src/indexer/inverted-index.ts 文件

### 2.1 addTermToIndex 方法 ⚠️ 需要重点检查

**原始逻辑：**
- 获取现有项：`store.get(term)`
- 如果存在：
  - 将 `item.docIds` 从数组转换为 Set（如果还不是 Set）
  - 检查 docId 是否在数组中
  - 如果不在，添加到数组
  - 转换回数组存储：`store.put({ term, docIds: Array.from(item.docIds), count })`
- 如果不存在：
  - 创建新项：`store.add({ term, docIds: [docId], count: 1 })`

**新逻辑：**
- 获取现有项：`await this.invertedIndexStore.get(term)`
  - InvertedIndexStore.get 内部：从数组转换为 Set 返回
- 如果存在：
  - 检查 `existingItem.docIds.has(docId)`（docIds 是 Set）
  - 如果不在，添加到 Set：`existingItem.docIds.add(docId)`
  - 更新 count：`existingItem.count = existingItem.docIds.size`
  - 保存：`await this.invertedIndexStore.put(existingItem)`
    - InvertedIndexStore.put 内部：将 Set 转换为数组存储
- 如果不存在：
  - 创建新项：`newItem = { term, docIds: new Set([docId]), count: 1 }`
  - 保存：`await this.invertedIndexStore.add(newItem)`
    - InvertedIndexStore.add 内部：将 Set 转换为数组存储

**关键差异分析：**
1. **Set ↔ 数组转换**：Store 类在 get 时从数组转 Set，put/add 时从 Set 转数组
2. **原逻辑**：直接操作数组，手动转换为 Set 进行操作
3. **新逻辑**：始终使用 Set 进行操作，Store 负责转换

**✅ 结论：逻辑等价，但实现方式更优雅**
- 数据存储格式相同（都是数组）
- 逻辑行为相同（检查是否存在、添加、更新 count）
- 只是中间操作的抽象层级不同

---

### 2.2 findDocumentsByTerm 方法

**原始逻辑：**
```typescript
return new Promise((resolve, reject) => {
  const store = this.db.getStore(STORE_NAMES.INVERTED_INDEX);
  const request = store.get(term);
  request.onsuccess = () => {
    if (request.result) {
      const item = request.result;
      const docIds = Array.isArray(item.docIds)
        ? new Set<string>(item.docIds as string[])
        : new Set<string>();
      resolve(docIds);
    } else {
      resolve(new Set<string>());
    }
  };
  request.onerror = () => reject(request.error);
});
```

**新逻辑：**
```typescript
const item = await this.invertedIndexStore.get(term);
if (item) {
  return item.docIds; // 已经是 Set
}
return new Set<string>();
```

**InvertedIndexStore.get 实现：**从数组转换为 Set 返回

**✅ 结论：逻辑一致**

---

### 2.3 getDocumentTerms 方法

**原始逻辑：**
```typescript
return new Promise((resolve, reject) => {
  const store = this.db.getStore(STORE_NAMES.DOC_TERMS);
  const index = store.index('docId');
  const request = index.getAll(docId);
  request.onsuccess = () => {
    const terms = new Set<string>();
    if (request.result) {
      for (const docTerm of request.result) {
        terms.add(docTerm.term);
      }
    }
    resolve(terms);
  };
  request.onerror = () => reject(request.error);
});
```

**新逻辑：**
```typescript
const docTerms = await this.docTermsStore.getByDocId(docId);
const terms = new Set<string>();
for (const docTerm of docTerms) {
  terms.add(docTerm.term);
}
return terms;
```

**DocTermsStore.getByDocId 实现：**
```typescript
async getByDocId(docId: string): Promise<DocTerm[]> {
  return new Promise((resolve, reject) => {
    const store = this.db.getStore(STORE_NAMES.DOC_TERMS);
    const index = store.index(INDEX_NAMES.DOC_ID);
    const request = index.getAll(docId);
    request.onsuccess = () => {
      resolve(request.result || []);
    };
    request.onerror = () => reject(request.error);
  });
}
```

**✅ 结论：逻辑一致**（使用 INDEX_NAMES.DOC_ID 代替硬编码 'docId'，更规范）

---

### 2.4 removeTermFromIndex 方法

**原始逻辑：**
- 获取项：`store.get(term)`
- 如果存在：
  - 将 docIds 转为数组
  - 查找 docId 的索引
  - 如果找到，从数组删除
  - 更新 count
  - 如果数组为空，删除整个项；否则更新项

**新逻辑：**
- 获取项：`await this.invertedIndexStore.get(term)`（返回 Set）
- 如果存在且 Set 包含 docId：
  - 从 Set 删除：`item.docIds.delete(docId)`
  - 更新 count：`item.count = item.docIds.size`
  - 如果 Set 为空，删除整个项；否则更新项

**✅ 结论：逻辑等价**
- 原始逻辑：操作数组
- 新逻辑：操作 Set
- 最终结果相同

---

### 2.5 removeDocTerms 方法

**原始逻辑：**
```typescript
return new Promise((resolve, reject) => {
  const store = this.db.getStore(STORE_NAMES.DOC_TERMS, 'readwrite');
  const index = store.index('docId');
  const request = index.openCursor(IDBKeyRange.only(docId));
  request.onsuccess = () => {
    const cursor = request.result;
    if (cursor) {
      cursor.delete();
      cursor.continue();
    } else {
      resolve();
    }
  };
  request.onerror = () => reject(request.error);
});
```

**新逻辑：**
```typescript
await this.docTermsStore.deleteByDocId(docId);
```

**DocTermsStore.deleteByDocId 实现：**与原始逻辑完全相同（使用 INDEX_NAMES.DOC_ID）

**✅ 结论：逻辑一致**

---

### 2.6 getAllTerms 方法

**原始逻辑：**
```typescript
return new Promise((resolve, reject) => {
  const store = this.db.getStore(STORE_NAMES.INVERTED_INDEX);
  const request = store.getAllKeys();
  request.onsuccess = () => {
    resolve(request.result as string[]);
  };
  request.onerror = () => reject(request.error);
});
```

**新逻辑：**
```typescript
return await this.invertedIndexStore.getAllKeys();
```

**InvertedIndexStore.getAllKeys 实现：**与原始逻辑完全相同

**✅ 结论：逻辑一致**

---

## 总结

### ✅ 所有逻辑保持一致

1. **功能等价性**：所有方法的功能行为与原始代码完全一致
2. **数据格式**：数据存储格式保持不变（Set ↔ 数组转换在 Store 层完成）
3. **错误处理**：新代码的错误处理略有增强（提供了更详细的错误信息）
4. **代码质量**：
   - 更好的代码组织（职责分离）
   - 更易维护（Store 类可复用）
   - 更规范的常量使用（INDEX_NAMES.DOC_ID 代替硬编码）

### ⚠️ 唯一需要注意的点

**InvertedIndexStore 的 Set ↔ 数组转换**：
- Store.get() 方法从数据库读取时，将数组转换为 Set
- Store.put() 和 Store.add() 方法保存时，将 Set 转换为数组
- 这确保了与原始代码的数据存储格式完全兼容
- 但在内存中操作时使用 Set，更符合逻辑语义

**结论：这是一次成功的重构，逻辑完全保持一致，代码质量有所提升。**

